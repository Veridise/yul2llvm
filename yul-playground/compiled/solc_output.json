{"contracts":{"control-flow/for-loop.sol":{"ForLoopTestContract":{"abi":[{"inputs":[{"internalType":"uint256","name":"a","type":"uint256"}],"name":"loop","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}],"ir":"\n/// @use-src 0:\"control-flow/for-loop.sol\"\nobject \"ForLoopTestContract_29\" {\n    code {\n        /// @src 0:119:291  \"contract ForLoopTestContract {...\"\n        mstore(64, memoryguard(128))\n        if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\n\n        constructor_ForLoopTestContract_29()\n\n        let _1 := allocate_unbounded()\n        codecopy(_1, dataoffset(\"ForLoopTestContract_29_deployed\"), datasize(\"ForLoopTestContract_29_deployed\"))\n\n        return(_1, datasize(\"ForLoopTestContract_29_deployed\"))\n\n        function allocate_unbounded() -> memPtr {\n            memPtr := mload(64)\n        }\n\n        function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\n            revert(0, 0)\n        }\n\n        /// @src 0:119:291  \"contract ForLoopTestContract {...\"\n        function constructor_ForLoopTestContract_29() {\n\n            /// @src 0:119:291  \"contract ForLoopTestContract {...\"\n\n        }\n        /// @src 0:119:291  \"contract ForLoopTestContract {...\"\n\n    }\n    /// @use-src 0:\"control-flow/for-loop.sol\"\n    object \"ForLoopTestContract_29_deployed\" {\n        code {\n            /// @src 0:119:291  \"contract ForLoopTestContract {...\"\n            mstore(64, memoryguard(128))\n\n            if iszero(lt(calldatasize(), 4))\n            {\n                let selector := shift_right_224_unsigned(calldataload(0))\n                switch selector\n\n                case 0x0b7d796e\n                {\n                    // loop(uint256)\n\n                    external_fun_loop_28()\n                }\n\n                default {}\n            }\n\n            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74()\n\n            function shift_right_224_unsigned(value) -> newValue {\n                newValue :=\n\n                shr(224, value)\n\n            }\n\n            function allocate_unbounded() -> memPtr {\n                memPtr := mload(64)\n            }\n\n            function revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() {\n                revert(0, 0)\n            }\n\n            function revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() {\n                revert(0, 0)\n            }\n\n            function revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db() {\n                revert(0, 0)\n            }\n\n            function cleanup_t_uint256(value) -> cleaned {\n                cleaned := value\n            }\n\n            function validator_revert_t_uint256(value) {\n                if iszero(eq(value, cleanup_t_uint256(value))) { revert(0, 0) }\n            }\n\n            function abi_decode_t_uint256(offset, end) -> value {\n                value := calldataload(offset)\n                validator_revert_t_uint256(value)\n            }\n\n            function abi_decode_tuple_t_uint256(headStart, dataEnd) -> value0 {\n                if slt(sub(dataEnd, headStart), 32) { revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b() }\n\n                {\n\n                    let offset := 0\n\n                    value0 := abi_decode_t_uint256(add(headStart, offset), dataEnd)\n                }\n\n            }\n\n            function abi_encode_t_uint256_to_t_uint256_fromStack(value, pos) {\n                mstore(pos, cleanup_t_uint256(value))\n            }\n\n            function abi_encode_tuple_t_uint256__to_t_uint256__fromStack(headStart , value0) -> tail {\n                tail := add(headStart, 32)\n\n                abi_encode_t_uint256_to_t_uint256_fromStack(value0,  add(headStart, 0))\n\n            }\n\n            function external_fun_loop_28() {\n\n                if callvalue() { revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb() }\n                let param_0 :=  abi_decode_tuple_t_uint256(4, calldatasize())\n                let ret_0 :=  fun_loop_28(param_0)\n                let memPos := allocate_unbounded()\n                let memEnd := abi_encode_tuple_t_uint256__to_t_uint256__fromStack(memPos , ret_0)\n                return(memPos, sub(memEnd, memPos))\n\n            }\n\n            function revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74() {\n                revert(0, 0)\n            }\n\n            function zero_value_for_split_t_uint256() -> ret {\n                ret := 0\n            }\n\n            function cleanup_t_rational_0_by_1(value) -> cleaned {\n                cleaned := value\n            }\n\n            function identity(value) -> ret {\n                ret := value\n            }\n\n            function convert_t_rational_0_by_1_to_t_uint256(value) -> converted {\n                converted := cleanup_t_uint256(identity(cleanup_t_rational_0_by_1(value)))\n            }\n\n            function panic_error_0x11() {\n                mstore(0, 35408467139433450592217433187231851964531694900788300625387963629091585785856)\n                mstore(4, 0x11)\n                revert(0, 0x24)\n            }\n\n            function increment_t_uint256(value) -> ret {\n                value := cleanup_t_uint256(value)\n                if eq(value, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff) { panic_error_0x11() }\n                ret := add(value, 1)\n            }\n\n            function cleanup_t_rational_10_by_1(value) -> cleaned {\n                cleaned := value\n            }\n\n            function convert_t_rational_10_by_1_to_t_uint256(value) -> converted {\n                converted := cleanup_t_uint256(identity(cleanup_t_rational_10_by_1(value)))\n            }\n\n            function cleanup_t_rational_1_by_1(value) -> cleaned {\n                cleaned := value\n            }\n\n            function convert_t_rational_1_by_1_to_t_uint256(value) -> converted {\n                converted := cleanup_t_uint256(identity(cleanup_t_rational_1_by_1(value)))\n            }\n\n            function checked_add_t_uint256(x, y) -> sum {\n                x := cleanup_t_uint256(x)\n                y := cleanup_t_uint256(y)\n\n                // overflow, if x > (maxValue - y)\n                if gt(x, sub(0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, y)) { panic_error_0x11() }\n\n                sum := add(x, y)\n            }\n\n            /// @ast-id 28\n            /// @src 0:155:289  \"function loop(uint256 a) external returns (uint256) {...\"\n            function fun_loop_28(var_a_3) -> var__6 {\n                /// @src 0:198:205  \"uint256\"\n                let zero_t_uint256_1 := zero_value_for_split_t_uint256()\n                var__6 := zero_t_uint256_1\n\n                /// @src 0:217:260  \"for(uint256 i=0;i<10;i++)...\"\n                for {\n                    /// @src 0:231:232  \"0\"\n                    let expr_10 := 0x00\n                    /// @src 0:221:232  \"uint256 i=0\"\n                    let var_i_9 := convert_t_rational_0_by_1_to_t_uint256(expr_10)\n                    } 1 {\n                    /// @src 0:238:241  \"i++\"\n                    let _3 := var_i_9\n                    let _2 := increment_t_uint256(_3)\n                    var_i_9 := _2\n                    let expr_16 := _3\n                }\n                {\n                    /// @src 0:233:234  \"i\"\n                    let _4 := var_i_9\n                    let expr_12 := _4\n                    /// @src 0:235:237  \"10\"\n                    let expr_13 := 0x0a\n                    /// @src 0:233:237  \"i<10\"\n                    let expr_14 := lt(cleanup_t_uint256(expr_12), convert_t_rational_10_by_1_to_t_uint256(expr_13))\n                    if iszero(expr_14) { break }\n                    /// @src 0:257:258  \"a\"\n                    let _5 := var_a_3\n                    let expr_19 := _5\n                    /// @src 0:259:260  \"1\"\n                    let expr_20 := 0x01\n                    /// @src 0:257:260  \"a+1\"\n                    let expr_21 := checked_add_t_uint256(expr_19, convert_t_rational_1_by_1_to_t_uint256(expr_20))\n\n                    /// @src 0:255:260  \"a=a+1\"\n                    var_a_3 := expr_21\n                    let expr_22 := expr_21\n                }\n                /// @src 0:281:282  \"a\"\n                let _6 := var_a_3\n                let expr_25 := _6\n                /// @src 0:274:282  \"return a\"\n                var__6 := expr_25\n                leave\n\n            }\n            /// @src 0:119:291  \"contract ForLoopTestContract {...\"\n\n        }\n\n        data \".metadata\" hex\"a26469706673582212205a4d085dd747f0736f664928519ec16f6a053aecdb15cf1deb5dc98a6f0d3d3564736f6c634300080f0033\"\n    }\n\n}\n\n","storageLayout":{"storage":[],"types":null}}}},"errors":[{"component":"general","errorCode":"2018","formattedMessage":"Warning: Function state mutability can be restricted to pure\n  --> control-flow/for-loop.sol:10:5:\n   |\n10 |     function loop(uint256 a) external returns (uint256) {\n   |     ^ (Relevant source part starts here and spans across multiple lines).\n\n","message":"Function state mutability can be restricted to pure","severity":"warning","sourceLocation":{"end":289,"file":"control-flow/for-loop.sol","start":155},"type":"Warning"}],"sources":{"control-flow/for-loop.sol":{"id":0}}}
